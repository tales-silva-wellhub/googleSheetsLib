{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bem-vindo \u00e0 Documenta\u00e7\u00e3o de googleSheetsLib","text":"<p>Esta biblioteca serve como um wrapper robusto para a Google Sheets API. A ideia \u00e9 facilitar drasticamente a opera\u00e7\u00e3o com as Spreadsheets usando Python, abstra\u00edndo a complica\u00e7\u00e3o de dominar os endpoints e a sintaxe do Google.</p>"},{"location":"#instalacao","title":"Instala\u00e7\u00e3o","text":"<p>Baixe o arquivo e extraia em alguma pasta de m\u00f3dulos. V\u00e1 at\u00e9 a pasta em que extraiu os arquivos e execute o pip install.</p> <pre><code>cd pasta_de_modulo/googleSheetsLib\npip install .\n</code></pre> <p>Agora \u00e9 poss\u00edvel importar o m\u00f3dulo normalmente. <pre><code>from googleSheetsLib import Spreadsheet\n\n# Instanciando um objeto Spreadsheet\nss = Spreadsheet(spreadsheet_id = '1WUBUMIw0fk_dnFO_jnMUTCMS_t_esnYKPYndZIFXhIs',\n                 token_fp = 'auth/token.json',\n                 cred_fp = 'auth/cred.json')\n\n# Acessando uma aba:\nsales = ss['Sales']\n\n# Acessando um range:\nvalues = sales['A1:G12']\n\n# Atualizando uma c\u00e9lula:\nsales['B1'] = 'Produto'\n</code></pre></p>"},{"location":"references/models/","title":"Models","text":""},{"location":"references/models/#googleSheetsLib.models.InputOption","title":"<code>googleSheetsLib.models.InputOption = Literal['RAW', 'USER_ENTERED']</code>  <code>module-attribute</code>","text":"<p>Determines how input data should be interpreted.</p> Values <p>RAW: The values the user has entered will not be parsed and will be stored as-is. USER_ENTERED: The values will be parsed as if the user typed them into the UI.                Numbers will stay as numbers, but strings may be converted to numbers,                dates, etc.</p>"},{"location":"references/models/#googleSheetsLib.models.InsertDataOption","title":"<code>googleSheetsLib.models.InsertDataOption = Literal['INSERT_ROWS', 'OVERWRITE']</code>  <code>module-attribute</code>","text":"<p>Determines how existing data is changed when new data is input.</p> Values <p>INSERT_ROWS: Rows are inserted for the new data. OVERWRITE: The new data overwrites existing data in the areas it covers.</p>"},{"location":"references/models/#googleSheetsLib.models.MajorDimension","title":"<code>googleSheetsLib.models.MajorDimension = Literal['ROWS', 'COLUMNS']</code>  <code>module-attribute</code>","text":"<p>Indicates which dimension operations should apply to.</p> Values <p>ROWS: Operates on rows (horizontal). COLUMNS: Operates on columns (vertical).</p>"},{"location":"references/responses/","title":"Responses & Errors","text":""},{"location":"references/responses/#googleSheetsLib.models.Response","title":"<code>googleSheetsLib.models.Response</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Universal response wrapper for all library operations.</p> <p>This class uses Generics (<code>T</code>) to allow type checkers to understand the  structure of the returned data.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>T</code> <p>The payload returned by the operation (e.g., a Sheet object,  a dictionary of values, or a list). Is <code>None</code> if the operation failed or the the request doesn't expect a data response.</p> <code>error</code> <code>SheetsError</code> <p>An error object containing details if the operation failed.</p> <code>ok</code> <code>bool</code> <p>Success flag. Returns <code>True</code> if the operation succeeded, <code>False</code> otherwise.</p> <code>date</code> <code>datetime</code> <p>Timestamp of when the response object was created.</p> <code>details</code> <code>Any</code> <p>Extra metadata or debugging info regarding the request execution. Generally structured like a dcitionary with the request's information.</p> Source code in <code>src/googleSheetsLib/models.py</code> <pre><code>@dataclass\nclass Response(Generic[T]):\n    \"\"\"\n    Universal response wrapper for all library operations.\n\n    This class uses Generics (`T`) to allow type checkers to understand the \n    structure of the returned data.\n\n    Attributes:\n        data (T, optional): The payload returned by the operation (e.g., a Sheet object, \n            a dictionary of values, or a list). Is `None` if the operation failed or the the request\n            doesn't expect a data response.\n        error (SheetsError, optional): An error object containing details if the operation failed.\n        ok (bool): Success flag. Returns `True` if the operation succeeded, `False` otherwise.\n        date (datetime): Timestamp of when the response object was created.\n        details (Any, optional): Extra metadata or debugging info regarding the request execution.\n            Generally structured like a dcitionary with the request's information.\n    \"\"\"\n\n    data: Optional[T] = None\n    error: Optional[SheetsError] = None\n    ok: bool = False\n    date: datetime = field(default_factory=datetime.now)\n    details: Optional[Any] = None\n\n    @classmethod\n    def success(cls, data: T = None, details = None) -&gt; \"Response[T]\":\n        \"\"\"\n        Factory method to create a successful response.\n\n        Args:\n            data (T, optional): The result of the operation.\n            details (Any, optional): Additional metadata.\n\n        Returns:\n            Response[T]: A response object with `ok=True` and populated data.\n        \"\"\"\n        return cls(ok=True, data=data, error=None, details = details)\n\n    @classmethod\n    def fail(cls, message: str, \n             code: Optional[int] = None, \n             function_name: Optional[str] = None,\n             details: Optional[Any] = None) -&gt; \"Response[Any]\":\n        \"\"\"\n        Factory method to create a failure response.\n\n        Args:\n            message (str): Description of what went wrong.\n            code (int, optional): Error code associated with the failure.\n            function_name (str, optional): Context of where the error originated.\n            details (Any, optional): Raw exception or error data.\n\n        Returns:\n            Response[Any]: A response object with `ok=False` and a populated `SheetsError`.\n        \"\"\"\n        return cls(ok=False, data=None, error=SheetsError(message=message, code=code, function_name=function_name, details=details))\n</code></pre>"},{"location":"references/responses/#googleSheetsLib.models.Response.fail","title":"<code>fail(message, code=None, function_name=None, details=None)</code>  <code>classmethod</code>","text":"<p>Factory method to create a failure response.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Description of what went wrong.</p> required <code>code</code> <code>int</code> <p>Error code associated with the failure.</p> <code>None</code> <code>function_name</code> <code>str</code> <p>Context of where the error originated.</p> <code>None</code> <code>details</code> <code>Any</code> <p>Raw exception or error data.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[Any]</code> <p>Response[Any]: A response object with <code>ok=False</code> and a populated <code>SheetsError</code>.</p> Source code in <code>src/googleSheetsLib/models.py</code> <pre><code>@classmethod\ndef fail(cls, message: str, \n         code: Optional[int] = None, \n         function_name: Optional[str] = None,\n         details: Optional[Any] = None) -&gt; \"Response[Any]\":\n    \"\"\"\n    Factory method to create a failure response.\n\n    Args:\n        message (str): Description of what went wrong.\n        code (int, optional): Error code associated with the failure.\n        function_name (str, optional): Context of where the error originated.\n        details (Any, optional): Raw exception or error data.\n\n    Returns:\n        Response[Any]: A response object with `ok=False` and a populated `SheetsError`.\n    \"\"\"\n    return cls(ok=False, data=None, error=SheetsError(message=message, code=code, function_name=function_name, details=details))\n</code></pre>"},{"location":"references/responses/#googleSheetsLib.models.Response.success","title":"<code>success(data=None, details=None)</code>  <code>classmethod</code>","text":"<p>Factory method to create a successful response.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The result of the operation.</p> <code>None</code> <code>details</code> <code>Any</code> <p>Additional metadata.</p> <code>None</code> <p>Returns:</p> Type Description <code>Response[T]</code> <p>Response[T]: A response object with <code>ok=True</code> and populated data.</p> Source code in <code>src/googleSheetsLib/models.py</code> <pre><code>@classmethod\ndef success(cls, data: T = None, details = None) -&gt; \"Response[T]\":\n    \"\"\"\n    Factory method to create a successful response.\n\n    Args:\n        data (T, optional): The result of the operation.\n        details (Any, optional): Additional metadata.\n\n    Returns:\n        Response[T]: A response object with `ok=True` and populated data.\n    \"\"\"\n    return cls(ok=True, data=data, error=None, details = details)\n</code></pre>"},{"location":"references/responses/#googleSheetsLib.models.SheetsError","title":"<code>googleSheetsLib.models.SheetsError</code>  <code>dataclass</code>","text":"<p>Standardized error container for API or library exceptions.</p> <p>This class encapsulates error details to provide a consistent error handling  experience across the library.</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>A human-readable description of the error.</p> <code>code</code> <code>int</code> <p>The HTTP status code (e.g., 404, 500) or internal error code.</p> <code>reason</code> <code>str</code> <p>The API error reason (e.g., 'invalid_grant', 'notFound').</p> <code>function_name</code> <code>str</code> <p>The name of the method/function where the error occurred. Useful for debugging the call stack.</p> <code>details</code> <code>Any</code> <p>Raw error payload or traceback information.</p> Source code in <code>src/googleSheetsLib/models.py</code> <pre><code>@dataclass\nclass SheetsError:\n    \"\"\"\n    Standardized error container for API or library exceptions.\n\n    This class encapsulates error details to provide a consistent error handling \n    experience across the library.\n\n    Attributes:\n        message (str): A human-readable description of the error.\n        code (int, optional): The HTTP status code (e.g., 404, 500) or internal error code.\n        reason (str, optional): The API error reason (e.g., 'invalid_grant', 'notFound').\n        function_name (str, optional): The name of the method/function where the error occurred.\n            Useful for debugging the call stack.\n        details (Any, optional): Raw error payload or traceback information.\n    \"\"\"\n    message: str\n    code: Optional[int] = None\n    reason: Optional[str] = None\n    function_name: Optional[str] = None\n    details: Any = None\n</code></pre>"},{"location":"references/sheet/","title":"Sheet Handler","text":""},{"location":"references/sheet/#googleSheetsLib.core.Sheet","title":"<code>googleSheetsLib.core.Sheet</code>","text":"<p>Interface that deals with Sheets at the tab level via API.</p> <p>This shouldn't be instanced directly, and instead it's expected to be created via the Spreadsheet class using the get methods.</p> <p>The interface with the service and ClientWrapper are derived from it's parent Spreadsheet object.</p> <p>For more information on the API, visit: https://developers.google.com/workspace/sheets/api/quickstart/python</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The tab name, the same as in Google Sheets.</p> <code>id</code> <code>int</code> <p>Numeric id that uniquely identifies the Sheet in a Spreadsheet.</p> <code>client</code> <code>ClientWrapper</code> <p>Handler for API requests, authentication, and retry logic. References parent Spreadsheet.</p> <code>service</code> <code>SpreadsheetResource</code> <p>The authenticated Google Sheets API resource. References parent spreadsheet.</p> <code>row_count</code> <code>int</code> <p>Count of rows in the tab. Only updated after a metadata refresh.</p> <code>column_count</code> <code>int</code> <p>Count of columns in the tab. Only updated after a metadata refresh.</p> <code>parent_spreadsheet</code> <code>Spreadsheet</code> <p>Spreadsheet object that originated this Sheet.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tab name.</p> required <code>id</code> <code>int</code> <p>Tab id.</p> required <code>parent_spreadsheet</code> <code>Spreadsheet</code> <p>Parent Spreadsheet,</p> required <code>client</code> <code>ClientWrapper</code> <p>Client interface to handle requests </p> required <code>service</code> <code>SpreadsheetsResource</code> <p>Google Sheets API resource to create requests.</p> required <code>row_count</code> <code>int</code> <p>Number of rows.</p> <code>0</code> <code>column_count</code> <code>int</code> <p>Number of columns.</p> <code>0</code> Notes <p>Do not instantiate this directly. References parent Spreadsheet while it exists, but not all requests need to go through the parent Spreadsheet object.</p> Example <pre><code># Instantiating Sheet object\ntab = ss['Tab Name']\n\n# Accessing values from the tab\nvalues = tab['A1:G22']\n\n# Updating a range in the tab\nvalues = [[1,2],\n          [3,4]]\ntab.update(rng = 'C3:D4', values = values)\n\n# Also works\ntab['C3:D4'] = values\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>class Sheet:\n    \"\"\"\n    Interface that deals with Sheets at the tab level via API.\n\n    This shouldn't be instanced directly, and instead it's expected to be created\n    via the Spreadsheet class using the get methods.\n\n    The interface with the service and ClientWrapper are derived from it's parent Spreadsheet object.\n\n    For more information on the API, visit:\n    https://developers.google.com/workspace/sheets/api/quickstart/python\n\n    Attributes:\n        name (str): The tab name, the same as in Google Sheets.\n        id (int): Numeric id that uniquely identifies the Sheet in a Spreadsheet.\n        client (ClientWrapper): Handler for API requests, authentication, and retry logic. References parent Spreadsheet.\n        service (SpreadsheetResource): The authenticated Google Sheets API resource. References parent spreadsheet.\n        row_count (int): Count of rows in the tab. Only updated after a metadata refresh.\n        column_count (int): Count of columns in the tab. Only updated after a metadata refresh.\n        parent_spreadsheet (Spreadsheet): Spreadsheet object that originated this Sheet.\n\n    Args:\n        name (str): Tab name.\n        id (int): Tab id.\n        parent_spreadsheet (Spreadsheet): Parent Spreadsheet,\n        client (ClientWrapper): Client interface to handle requests \n        service (SpreadsheetsResource): Google Sheets API resource to create requests.\n        row_count (int, optional): Number of rows.\n        column_count (int, optional): Number of columns.\n\n    Notes:\n        Do not instantiate this directly.\n        References parent Spreadsheet while it exists, but not all requests need to go\n        through the parent Spreadsheet object.\n\n\n    Example:\n        ```python\n        # Instantiating Sheet object\n        tab = ss['Tab Name']\n\n        # Accessing values from the tab\n        values = tab['A1:G22']\n\n        # Updating a range in the tab\n        values = [[1,2],\n                  [3,4]]\n        tab.update(rng = 'C3:D4', values = values)\n\n        # Also works\n        tab['C3:D4'] = values\n        ```\n    \"\"\"\n    def __init__(self,\n                 name:str,\n                 id:int,\n                 parent_spreadsheet: Spreadsheet,\n                 client:ClientWrapper,\n                 service,\n                 row_count:int = 0,\n                 column_count:int = 0):\n\n        self.name = name\n        self.id = id\n        self.spreadsheet_id = parent_spreadsheet.spreadsheet_id\n        self.service = service\n        self.client = client\n        self.row_count = row_count\n        self.column_count = column_count\n        self.parent_spreadsheet = parent_spreadsheet\n\n    def get_values(self, rng:str = '') -&gt; Response:\n        \"\"\"\n        Method to access the sheet's values. If range is not specified, returns the whole content if the sheet.\n        Returns a Response object with the values.\n        Can also by called by subscript notation, e.g. tab['A1:C2']\n\n        Args: \n            rng(str, optional): Range in the Excel Format. E.g `A1:Q22`, `A:Q`, `C32`.\n                If not specified, the values for the whole tab will be returned. \n\n        Returns:\n            Response: Response object with the sheet's data, if succeded, or error information, if failed.\n                The data is accessed by the Response.data attribute, and it's expected to be a list of lists (list of rows),\n                or a single value if only a single cell was requested.\n                If the range is not a valid xrange, it returns a Response with a 'Invalid Range' error.\n                All other errors are repassed as is via the Response.error object.\n\n        Notes:\n            If only a single cell is specified, the Response.data is a singular value.\n            All other times, it contains a list of lists or None.\n\n        Example:\n            ```python\n            # Requesting a range\n            response = tab.get_values('A2:C3') # Response.data = [[1,2,3],[4,5,6]]\n\n            # Requesting a row range using subscript:\n            response = tab['2:10'] # Response.data = [row2, row3, row4 ... ]\n\n            # Requesting a singular cell:\n            response = tab['C2'] # Response.data = 3\n\n            # Handling errors:\n            response = tab.get_values('A33sd:221AB2') # Invalid range\n            if response.error:\n                print(response.error.message) # 'Invalid x range: A33sd:221AB2'\n            ```\n        \"\"\"\n\n        details = self._get_dets(locals())\n        function_name = 'Sheet.get_values'\n\n        # Validando e formatando range\n        if rng:\n            is_valid_range = validate_xrange(rng)\n            if not is_valid_range:\n                print(f'Invalid range: {rng}.')\n                return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n            if '!' in rng:\n                rng = rng.split('!')[-1]\n            request_range = f'{self.name}!{rng}'\n        else:\n            request_range = f'{self.name}'\n\n        # Criando requisi\u00e7\u00e3o\n        try:\n            request = self.service.values().get( \n                spreadsheetId = self.spreadsheet_id,\n                range = request_range\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        # Fazendo requisi\u00e7\u00e3o\n        response = self.client.execute(request)\n\n        # Resolvendo resposta da requisi\u00e7\u00e3o\n        if response.ok:\n            details['range'] = request_range\n            if response.data:\n                response.data = response.data.get('values')\n                if is_cell(rng) and isinstance(response.data, list) and len(response.data[0]) == 1:\n                    response.data = response.data[0][0]\n\n            response.details = details\n\n        else:\n            if response.error:\n                response.error.details = details\n                response.error.function_name = function_name\n\n        return response\n\n    def append_values(self, values: list[list], \n                      rng:str = '',\n                      input_option: InputOption = 'USER_ENTERED',\n                      insert_data_option: InsertDataOption = 'INSERT_ROWS') -&gt; Response:\n        \"\"\"\n        This method inserts new data into the Spreadsheet's tab, starting at the specified range.\n\n        The values to be inserted can be larger than the specified range; the range just delimits\n        where the append starts.\n\n        Values also need to be formated as a list of lists, a 2D matrix where each value is stored\n        in an indexed `values[i][j]`.\n\n        Args:\n            values (list[list]): Values to be appended. Needed to be formated as a list of rows,\n                i.e. a 2D matrix. Try to keep the values to str and int types, as other object types tend\n                to trigger a bad request error.\n            rng (str): Range to start the append. Formated in Excel range (e.g. 'A1:B2'), can be a single cell\n                in which the API will append the whole set of values.\n            input_option (InputOption, optional): Input mode, defaulted to USER_ENTERED.\n            insert_data_option (InsertDataOption, optional): How to append, either by inserting new rows, or\n                by overwritting blank cells.\n\n        Returns:\n            Response: response object with the status of the request. Response.data defaults to None.\n                Returns a failed response if: the value list is empty; the range is invalid; selected\n                an invalid input or insert option; failed to build request; or request sent an error\n                response.\n\n        Notes:\n            The most common type of error here is badly formated value list. This means inputing something that is not\n            a list of lists, or inserting object types that are not supported. \n\n            A quick way to fix types is valling `values = [[str(val) for val in row] for row in values]`, \n            which converts every value to str.\n\n        Examples:\n            ```python\n            # appending values to a tab\n            values = [[1,2,3],\n                      [4,5,6]]\n            tab.append_values(rng = 'A1', values = values) # Will try to append the values to the first cell\n\n            # handling errors\n            invalid_values = []\n            response = tab.append_values(rng = 'C2:D4', values = invalid_values)\n            print(response.error) # No values to insert.\n            ```\n        \"\"\"\n\n        # Registrando dados para valida\u00e7\u00e3o depois.\n        details = self._get_dets(locals())\n        function_name = 'Sheet.append_values'\n\n        # Validando valores:\n        if not values:\n            return Response.fail(f'No values to insert.', function_name=function_name, details = details)\n\n        # Validando e formatando range.\n        if rng:\n            is_valid_range = validate_xrange(rng)\n            if not is_valid_range:\n                print(f'Invalid range: {rng}.')\n                return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n            if '!' in rng:\n                rng = rng.split('!')[-1]\n            request_range = f'{self.name}!{rng}'\n        else:\n            request_range = f'{self.name}'\n\n        # Validando as outras op\u00e7\u00f5es:\n        if input_option not in get_args(InputOption):\n            error_msg = f'Arg Error: Invalid input option: {input_option}.'\n            print(error_msg)\n            return Response.fail(error_msg, function_name=function_name, details=details)\n        if insert_data_option not in get_args(InsertDataOption):\n            error_msg = f'Arg Error: Invalid insert data option: {insert_data_option}.'\n            print(error_msg)\n            return Response.fail(error_msg, function_name=function_name, details=details)\n\n        # Preparando requisi\u00e7\u00e3o\n        body = {'values':values}\n\n        try:\n            request = self.service.values().append( \n                spreadsheetId = self.spreadsheet_id,\n                range = request_range,\n                valueInputOption = input_option,\n                insertDataOption = insert_data_option,\n                body = body\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        response = self.client.execute(request)\n\n        if response.ok:\n            result = response.data\n            if result:\n                details['range'] = request_range\n                details['table_range'] = result.get('tableRange')\n                if 'updates' in result:\n                    details['updated_range'] = result['updates'].get('updatedRange')\n            response.data = None\n            response.details = details\n            return response\n        else:\n            if response.error:\n                response.error.details = details\n                response.error.function_name = function_name\n            return response\n\n    def clear_cells(self, rng:str = '') -&gt; Response:\n        \"\"\"\n        Method to clear cells in a tab of the Spreadsheet. Will only empty the value of the cell,\n        otherwise keeping the format and other properties.\n\n        Args:\n            rng (str): range to clear, in Excel format (e.g. 'A1:G3', '1:12'). If left empty,\n                whole tab will be cleared, so be careful.\n\n        Returns:\n            Response: Response object with the status of the request. Returns an failed response if the\n                rng is invalid, if it failed to build the request, or if the API call returned\n                an error.\n\n        Example:\n            ```python\n            # clearing a few cells:\n            tab.clear_cells('A1:D9')\n\n            # clearing the whole tab\n            tab.clear_cells()\n            ```\n        \"\"\"\n        details = self._get_dets(locals())\n        function_name = 'Sheet.append_values'\n\n        if rng:\n            is_valid_range = validate_xrange(rng)\n            if not is_valid_range:\n                print(f'Invalid range: {rng}.')\n                return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n            if '!' in rng:\n                rng = rng.split('!')[-1]\n            request_range = f'{self.name}!{rng}'\n        else:\n            request_range = f'{self.name}'\n\n        # Constru\u00edndo a request:\n        try:\n            request = self.service.values().clear( \n                spreadsheetId = self.spreadsheet_id,\n                range = request_range\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        response = self.client.execute(request)\n\n        if response.ok:\n            result = response.data\n            if result:\n                details['range'] = request_range\n                details['cleared_range'] = result.get('clearedRange')\n            response.data = None\n            response.details = details\n            return response\n        else:\n            if response.error:\n                response.error.details = details\n                response.error.function_name = function_name\n            return response\n\n    def update(self,\n               values:list[list],\n               rng:str = 'A1', \n               value_input_option:InputOption = 'USER_ENTERED',\n               major_dimension:MajorDimension = 'ROWS'):\n        \"Fun\u00e7\u00e3o que atualiza c\u00e9lulas da planilha.\"\n\n        details = self._get_dets(locals())\n        function_name = 'Sheet.update'\n\n        if rng:\n            is_valid_range = validate_xrange(rng)\n            if not is_valid_range:\n                print(f'Invalid range: {rng}.')\n                return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n            if '!' in rng:\n                rng = rng.split('!')[-1]\n            if ':' not in rng:\n                rng = get_values_delta(rng, values)\n            request_range = f'{self.name}!{rng}'\n        else:\n            return Response.fail(f'No range specified.', function_name=function_name, details = details)\n\n        # Validando par\u00e2metros adicionais:\n        if major_dimension not in get_args(MajorDimension):\n            error_msg = f'Args Error: Invalid major dimension {major_dimension}'\n            return Response.fail(error_msg, function_name = function_name, details = details)\n        if value_input_option not in get_args(InputOption):\n            error_msg = f'Args Error: Invalid input option {value_input_option}'\n            return Response.fail(error_msg, function_name = function_name, details = details)\n\n        body = {\n            'values' : values,\n            'majorDimension' : major_dimension\n        }\n\n        try:\n            request = self.service.values().update(\n                range = request_range,\n                spreadsheetId = self.spreadsheet_id,\n                body = body, \n                valueInputOption = value_input_option\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        response = self.client.execute(request)\n\n        if response.ok:\n            result = response.data\n            if result:\n                details['range'] = request_range\n                details['updated_range'] = result.get('updatedRange')\n                details['updated_cells'] = result.get('updatedCells')\n                details['updated_rows'] = result.get('updatedRows')\n                details['updated_columns'] = result.get('updatedColumns')\n            response.data = None\n            response.details = details\n            return response\n        else:\n            if response.error:\n                response.error.details = details\n                response.error.function_name = function_name\n            return response\n\n    def update_cell(self, cell:str, value):\n\n        details = self._get_dets(locals())\n        function_name = 'Sheet.update_cell'\n\n        if not is_cell(cell):\n            print(f'Invalid cell format: {cell}')\n            return Response.fail(f'Invalid cell format: {cell}', function_name=function_name, details=details)\n\n\n        response = self.update(rng = cell, values = [[value]])\n\n        if response.ok:\n            updated_range = response.details.get('updatedRange') # type: ignore\n            response.details = details\n            response.details['updated_range'] = updated_range\n            response.details['cell'] = cell\n        elif response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n        return response\n\n    def autofill_drag(self, source_range:str, drag_distance:int, prepare = False, dimension:MajorDimension = 'ROWS'):\n\n        details = self._get_dets(locals())\n        function_name = 'Sheet.autofill_drag'\n\n        if drag_distance &lt; 0:\n            return Response.fail(f'Invalid drag distance: {drag_distance}.', function_name=function_name, details = details)\n\n        if dimension not in get_args(MajorDimension):\n            return Response.fail(f'Invalid dimension: {dimension}.', function_name=function_name, details = details)\n\n        if source_range:\n            if '!' in source_range:\n                source_range = source_range.split('!')[-1]\n            grid_range = xrange_to_grid_range(source_range)\n            if not grid_range:\n                return Response.fail(f'Invalid range.', function_name=function_name, details = details)\n        else:\n            return Response.fail(f'No range specified.', function_name=function_name, details = details)\n\n\n        grid_range['sheetId'] = self.id\n\n        autofill_request = {\n            'autoFill':{\n                'sourceAndDestination': {\n                    'source' : grid_range,\n                    'dimension' : dimension,\n                    'fillLength' : drag_distance\n                }\n            }\n        }\n\n        details['autofill_request'] = autofill_request\n\n        if prepare:\n            details['prepared'] = True\n            self.parent_spreadsheet.batch_requests.append(autofill_request)\n            return Response.success(details = details)\n\n        try:\n            body: BatchUpdateSpreadsheetRequest = {'requests' : [autofill_request]} # type: ignore\n            request = self.service.batchUpdate(\n                spreadsheetId=self.spreadsheet_id,\n                body = body\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        response = self.client.execute(request)\n\n        if response.ok:\n            response.details = details\n            response.data = None\n            return response\n        elif response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n        return response\n\n    def delete_rows(self, rng:str = '', start_row:int =-1, end_row:int=-1, prepare = False):\n        \"Fun\u00e7\u00e3o que deleta linhas da planilha. Pode receber tanto range, quanto pode receber start_row e end_row (base 1 inclusivo)\"\n\n        details = self._get_dets(locals())\n        function_name = 'Sheet.delete_rows'\n\n        if rng:\n            if '!' in rng:\n                rng = rng.split('!')[-1]\n            grid_range = xrange_to_grid_range(rng)\n            if not grid_range:\n                return Response.fail(f'Invalid range: {rng}', function_name=function_name, details=details)\n            elif grid_range['startRowIndex'] &lt; 0 or grid_range['endRowIndex'] &lt; 1:\n                return Response.fail(f'Invalid range: {rng}', function_name=function_name, details=details)\n            else:\n                start_index = grid_range['startRowIndex']\n                end_index = grid_range['endRowIndex']\n        if not rng:\n            if end_row == -1 and start_row == -1:\n                return Response.fail(f'Missing arguments: range or start_row and end_row', function_name=function_name, details=details)\n            if (end_row &lt; 1 or start_row &lt; 1) or end_row &lt; start_row:\n                return Response.fail(f'Invalid row ranges: {(start_row, end_row)}', function_name=function_name, details=details)\n            start_index = start_row - 1 # Offset de passar de base 1 pra base 0\n            end_index = end_row         # Mant\u00e9m, porque o \u00edndice \u00e9 exclusivo\n\n        delete_request = {\n            'deleteDimension' : {\n                'range': {\n                    'sheetId' : self.id,\n                    'dimension' : 'ROWS',\n                    'startIndex' : start_index,\n                    'endIndex' : end_index\n                }\n            }\n        }\n\n        details['delete_request'] = delete_request # Telemetria\n\n        if prepare:\n            details['prepared'] = True\n            self.parent_spreadsheet.batch_requests.append(delete_request)\n            return Response.success(details = details)    \n\n\n        try:\n            body: BatchUpdateSpreadsheetRequest = {'requests' : [delete_request]} # type: ignore\n            request = self.service.batchUpdate(\n                spreadsheetId=self.spreadsheet_id,\n                body = body\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        response = self.client.execute(request)\n\n        if response.ok:\n            response.details = details\n            response.data = None\n        elif response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n        return response\n\n    def refresh_metadata(self):\n        self.parent_spreadsheet.refresh_metadata()\n        metadata = dict()\n        for sheet_info in self.parent_spreadsheet.sheets_info.values():\n            if sheet_info['sheet_id'] == self.id or sheet_info['title'] == self.name:\n                metadata = sheet_info\n                break\n        if metadata:\n            self.name = metadata['title']\n            self.id = metadata['sheet_id']\n            self.row_count = metadata['row_count']\n            self.column_count = metadata['column_count']\n        else:\n            print(f'N\u00e3o foi poss\u00edvel localizar metadados da aba {self.name}. Possivelmente foi deletada.')\n\n    def __str__(self):\n        return f'Sheet Object \"{self.name}\"; Id = {self.id}; Parent Spreadsheet = {self.parent_spreadsheet.name}; Rows = {self.row_count}; Columns = {self.column_count}'\n\n    def get_info(self) -&gt; dict:\n        return {\n            'title': self.name,\n            'sheet_id' : self.id,\n            'row_count' : self.row_count,\n            'column_count' : self.column_count,\n            'parent_spreadsheet': self.parent_spreadsheet.name\n        }\n\n    def _get_dets(self, locals:dict) -&gt; dict:\n        deets = locals.copy()\n        if 'self' in deets:\n            del deets['self']\n        deets['sheet_info'] = self.get_info()\n        return deets\n\n    def __getitem__(self, rng) -&gt; Response:\n        result = self.get_values(rng)\n        if result.data:\n            return result.data\n        else:\n            return result\n\n    def __setitem__(self, rng, new_value) -&gt; Response:\n        if is_cell(rng) and not isinstance(new_value, list):\n            return self.update_cell(cell = rng, value = new_value)\n        else:\n            return self.update(rng = rng, values = new_value)\n\n    def to_csv(self, fp, rng = '', sep = ','):\n        \"Fun\u00e7\u00e3o que pega os dados de uma planilha e salva em formato CSV.\"\n        values = self.get_values(rng)\n        if values.data:\n            pd.DataFrame(values.data).to_csv(fp, index = False, sep = sep, header = False)\n\n    def to_df(self, rng = '', headers = [], dtype = None):\n        values = self.get_values(rng).data\n        try:\n            if values:\n                if not headers and len(values)&gt;1:\n                    headers = values[0]\n                    values = values[1:]\n                if not headers:\n                    headers = [n for n in range(len(values[0]))]\n                return pd.DataFrame(values, columns = headers, dtype = dtype)\n            else:\n                return pd.DataFrame()\n        except Exception as e:\n            print(f\"Not possible to create dataframe: {e}.\\nReturning empty one instead.\")\n            return pd.DataFrame()\n</code></pre>"},{"location":"references/sheet/#googleSheetsLib.core.Sheet.append_values","title":"<code>append_values(values, rng='', input_option='USER_ENTERED', insert_data_option='INSERT_ROWS')</code>","text":"<p>This method inserts new data into the Spreadsheet's tab, starting at the specified range.</p> <p>The values to be inserted can be larger than the specified range; the range just delimits where the append starts.</p> <p>Values also need to be formated as a list of lists, a 2D matrix where each value is stored in an indexed <code>values[i][j]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>list[list]</code> <p>Values to be appended. Needed to be formated as a list of rows, i.e. a 2D matrix. Try to keep the values to str and int types, as other object types tend to trigger a bad request error.</p> required <code>rng</code> <code>str</code> <p>Range to start the append. Formated in Excel range (e.g. 'A1:B2'), can be a single cell in which the API will append the whole set of values.</p> <code>''</code> <code>input_option</code> <code>InputOption</code> <p>Input mode, defaulted to USER_ENTERED.</p> <code>'USER_ENTERED'</code> <code>insert_data_option</code> <code>InsertDataOption</code> <p>How to append, either by inserting new rows, or by overwritting blank cells.</p> <code>'INSERT_ROWS'</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>response object with the status of the request. Response.data defaults to None. Returns a failed response if: the value list is empty; the range is invalid; selected an invalid input or insert option; failed to build request; or request sent an error response.</p> Notes <p>The most common type of error here is badly formated value list. This means inputing something that is not a list of lists, or inserting object types that are not supported. </p> <p>A quick way to fix types is valling <code>values = [[str(val) for val in row] for row in values]</code>,  which converts every value to str.</p> <p>Examples:</p> <pre><code># appending values to a tab\nvalues = [[1,2,3],\n          [4,5,6]]\ntab.append_values(rng = 'A1', values = values) # Will try to append the values to the first cell\n\n# handling errors\ninvalid_values = []\nresponse = tab.append_values(rng = 'C2:D4', values = invalid_values)\nprint(response.error) # No values to insert.\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def append_values(self, values: list[list], \n                  rng:str = '',\n                  input_option: InputOption = 'USER_ENTERED',\n                  insert_data_option: InsertDataOption = 'INSERT_ROWS') -&gt; Response:\n    \"\"\"\n    This method inserts new data into the Spreadsheet's tab, starting at the specified range.\n\n    The values to be inserted can be larger than the specified range; the range just delimits\n    where the append starts.\n\n    Values also need to be formated as a list of lists, a 2D matrix where each value is stored\n    in an indexed `values[i][j]`.\n\n    Args:\n        values (list[list]): Values to be appended. Needed to be formated as a list of rows,\n            i.e. a 2D matrix. Try to keep the values to str and int types, as other object types tend\n            to trigger a bad request error.\n        rng (str): Range to start the append. Formated in Excel range (e.g. 'A1:B2'), can be a single cell\n            in which the API will append the whole set of values.\n        input_option (InputOption, optional): Input mode, defaulted to USER_ENTERED.\n        insert_data_option (InsertDataOption, optional): How to append, either by inserting new rows, or\n            by overwritting blank cells.\n\n    Returns:\n        Response: response object with the status of the request. Response.data defaults to None.\n            Returns a failed response if: the value list is empty; the range is invalid; selected\n            an invalid input or insert option; failed to build request; or request sent an error\n            response.\n\n    Notes:\n        The most common type of error here is badly formated value list. This means inputing something that is not\n        a list of lists, or inserting object types that are not supported. \n\n        A quick way to fix types is valling `values = [[str(val) for val in row] for row in values]`, \n        which converts every value to str.\n\n    Examples:\n        ```python\n        # appending values to a tab\n        values = [[1,2,3],\n                  [4,5,6]]\n        tab.append_values(rng = 'A1', values = values) # Will try to append the values to the first cell\n\n        # handling errors\n        invalid_values = []\n        response = tab.append_values(rng = 'C2:D4', values = invalid_values)\n        print(response.error) # No values to insert.\n        ```\n    \"\"\"\n\n    # Registrando dados para valida\u00e7\u00e3o depois.\n    details = self._get_dets(locals())\n    function_name = 'Sheet.append_values'\n\n    # Validando valores:\n    if not values:\n        return Response.fail(f'No values to insert.', function_name=function_name, details = details)\n\n    # Validando e formatando range.\n    if rng:\n        is_valid_range = validate_xrange(rng)\n        if not is_valid_range:\n            print(f'Invalid range: {rng}.')\n            return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n        if '!' in rng:\n            rng = rng.split('!')[-1]\n        request_range = f'{self.name}!{rng}'\n    else:\n        request_range = f'{self.name}'\n\n    # Validando as outras op\u00e7\u00f5es:\n    if input_option not in get_args(InputOption):\n        error_msg = f'Arg Error: Invalid input option: {input_option}.'\n        print(error_msg)\n        return Response.fail(error_msg, function_name=function_name, details=details)\n    if insert_data_option not in get_args(InsertDataOption):\n        error_msg = f'Arg Error: Invalid insert data option: {insert_data_option}.'\n        print(error_msg)\n        return Response.fail(error_msg, function_name=function_name, details=details)\n\n    # Preparando requisi\u00e7\u00e3o\n    body = {'values':values}\n\n    try:\n        request = self.service.values().append( \n            spreadsheetId = self.spreadsheet_id,\n            range = request_range,\n            valueInputOption = input_option,\n            insertDataOption = insert_data_option,\n            body = body\n        )\n    except Exception as e:\n        return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n    response = self.client.execute(request)\n\n    if response.ok:\n        result = response.data\n        if result:\n            details['range'] = request_range\n            details['table_range'] = result.get('tableRange')\n            if 'updates' in result:\n                details['updated_range'] = result['updates'].get('updatedRange')\n        response.data = None\n        response.details = details\n        return response\n    else:\n        if response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n        return response\n</code></pre>"},{"location":"references/sheet/#googleSheetsLib.core.Sheet.clear_cells","title":"<code>clear_cells(rng='')</code>","text":"<p>Method to clear cells in a tab of the Spreadsheet. Will only empty the value of the cell, otherwise keeping the format and other properties.</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>str</code> <p>range to clear, in Excel format (e.g. 'A1:G3', '1:12'). If left empty, whole tab will be cleared, so be careful.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Response object with the status of the request. Returns an failed response if the rng is invalid, if it failed to build the request, or if the API call returned an error.</p> Example <pre><code># clearing a few cells:\ntab.clear_cells('A1:D9')\n\n# clearing the whole tab\ntab.clear_cells()\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def clear_cells(self, rng:str = '') -&gt; Response:\n    \"\"\"\n    Method to clear cells in a tab of the Spreadsheet. Will only empty the value of the cell,\n    otherwise keeping the format and other properties.\n\n    Args:\n        rng (str): range to clear, in Excel format (e.g. 'A1:G3', '1:12'). If left empty,\n            whole tab will be cleared, so be careful.\n\n    Returns:\n        Response: Response object with the status of the request. Returns an failed response if the\n            rng is invalid, if it failed to build the request, or if the API call returned\n            an error.\n\n    Example:\n        ```python\n        # clearing a few cells:\n        tab.clear_cells('A1:D9')\n\n        # clearing the whole tab\n        tab.clear_cells()\n        ```\n    \"\"\"\n    details = self._get_dets(locals())\n    function_name = 'Sheet.append_values'\n\n    if rng:\n        is_valid_range = validate_xrange(rng)\n        if not is_valid_range:\n            print(f'Invalid range: {rng}.')\n            return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n        if '!' in rng:\n            rng = rng.split('!')[-1]\n        request_range = f'{self.name}!{rng}'\n    else:\n        request_range = f'{self.name}'\n\n    # Constru\u00edndo a request:\n    try:\n        request = self.service.values().clear( \n            spreadsheetId = self.spreadsheet_id,\n            range = request_range\n        )\n    except Exception as e:\n        return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n    response = self.client.execute(request)\n\n    if response.ok:\n        result = response.data\n        if result:\n            details['range'] = request_range\n            details['cleared_range'] = result.get('clearedRange')\n        response.data = None\n        response.details = details\n        return response\n    else:\n        if response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n        return response\n</code></pre>"},{"location":"references/sheet/#googleSheetsLib.core.Sheet.delete_rows","title":"<code>delete_rows(rng='', start_row=-1, end_row=-1, prepare=False)</code>","text":"<p>Fun\u00e7\u00e3o que deleta linhas da planilha. Pode receber tanto range, quanto pode receber start_row e end_row (base 1 inclusivo)</p> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def delete_rows(self, rng:str = '', start_row:int =-1, end_row:int=-1, prepare = False):\n    \"Fun\u00e7\u00e3o que deleta linhas da planilha. Pode receber tanto range, quanto pode receber start_row e end_row (base 1 inclusivo)\"\n\n    details = self._get_dets(locals())\n    function_name = 'Sheet.delete_rows'\n\n    if rng:\n        if '!' in rng:\n            rng = rng.split('!')[-1]\n        grid_range = xrange_to_grid_range(rng)\n        if not grid_range:\n            return Response.fail(f'Invalid range: {rng}', function_name=function_name, details=details)\n        elif grid_range['startRowIndex'] &lt; 0 or grid_range['endRowIndex'] &lt; 1:\n            return Response.fail(f'Invalid range: {rng}', function_name=function_name, details=details)\n        else:\n            start_index = grid_range['startRowIndex']\n            end_index = grid_range['endRowIndex']\n    if not rng:\n        if end_row == -1 and start_row == -1:\n            return Response.fail(f'Missing arguments: range or start_row and end_row', function_name=function_name, details=details)\n        if (end_row &lt; 1 or start_row &lt; 1) or end_row &lt; start_row:\n            return Response.fail(f'Invalid row ranges: {(start_row, end_row)}', function_name=function_name, details=details)\n        start_index = start_row - 1 # Offset de passar de base 1 pra base 0\n        end_index = end_row         # Mant\u00e9m, porque o \u00edndice \u00e9 exclusivo\n\n    delete_request = {\n        'deleteDimension' : {\n            'range': {\n                'sheetId' : self.id,\n                'dimension' : 'ROWS',\n                'startIndex' : start_index,\n                'endIndex' : end_index\n            }\n        }\n    }\n\n    details['delete_request'] = delete_request # Telemetria\n\n    if prepare:\n        details['prepared'] = True\n        self.parent_spreadsheet.batch_requests.append(delete_request)\n        return Response.success(details = details)    \n\n\n    try:\n        body: BatchUpdateSpreadsheetRequest = {'requests' : [delete_request]} # type: ignore\n        request = self.service.batchUpdate(\n            spreadsheetId=self.spreadsheet_id,\n            body = body\n        )\n    except Exception as e:\n        return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n    response = self.client.execute(request)\n\n    if response.ok:\n        response.details = details\n        response.data = None\n    elif response.error:\n        response.error.details = details\n        response.error.function_name = function_name\n    return response\n</code></pre>"},{"location":"references/sheet/#googleSheetsLib.core.Sheet.get_values","title":"<code>get_values(rng='')</code>","text":"<p>Method to access the sheet's values. If range is not specified, returns the whole content if the sheet. Returns a Response object with the values. Can also by called by subscript notation, e.g. tab['A1:C2']</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>str</code> <p>Range in the Excel Format. E.g <code>A1:Q22</code>, <code>A:Q</code>, <code>C32</code>. If not specified, the values for the whole tab will be returned. </p> <code>''</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>Response object with the sheet's data, if succeded, or error information, if failed. The data is accessed by the Response.data attribute, and it's expected to be a list of lists (list of rows), or a single value if only a single cell was requested. If the range is not a valid xrange, it returns a Response with a 'Invalid Range' error. All other errors are repassed as is via the Response.error object.</p> Notes <p>If only a single cell is specified, the Response.data is a singular value. All other times, it contains a list of lists or None.</p> Example <pre><code># Requesting a range\nresponse = tab.get_values('A2:C3') # Response.data = [[1,2,3],[4,5,6]]\n\n# Requesting a row range using subscript:\nresponse = tab['2:10'] # Response.data = [row2, row3, row4 ... ]\n\n# Requesting a singular cell:\nresponse = tab['C2'] # Response.data = 3\n\n# Handling errors:\nresponse = tab.get_values('A33sd:221AB2') # Invalid range\nif response.error:\n    print(response.error.message) # 'Invalid x range: A33sd:221AB2'\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def get_values(self, rng:str = '') -&gt; Response:\n    \"\"\"\n    Method to access the sheet's values. If range is not specified, returns the whole content if the sheet.\n    Returns a Response object with the values.\n    Can also by called by subscript notation, e.g. tab['A1:C2']\n\n    Args: \n        rng(str, optional): Range in the Excel Format. E.g `A1:Q22`, `A:Q`, `C32`.\n            If not specified, the values for the whole tab will be returned. \n\n    Returns:\n        Response: Response object with the sheet's data, if succeded, or error information, if failed.\n            The data is accessed by the Response.data attribute, and it's expected to be a list of lists (list of rows),\n            or a single value if only a single cell was requested.\n            If the range is not a valid xrange, it returns a Response with a 'Invalid Range' error.\n            All other errors are repassed as is via the Response.error object.\n\n    Notes:\n        If only a single cell is specified, the Response.data is a singular value.\n        All other times, it contains a list of lists or None.\n\n    Example:\n        ```python\n        # Requesting a range\n        response = tab.get_values('A2:C3') # Response.data = [[1,2,3],[4,5,6]]\n\n        # Requesting a row range using subscript:\n        response = tab['2:10'] # Response.data = [row2, row3, row4 ... ]\n\n        # Requesting a singular cell:\n        response = tab['C2'] # Response.data = 3\n\n        # Handling errors:\n        response = tab.get_values('A33sd:221AB2') # Invalid range\n        if response.error:\n            print(response.error.message) # 'Invalid x range: A33sd:221AB2'\n        ```\n    \"\"\"\n\n    details = self._get_dets(locals())\n    function_name = 'Sheet.get_values'\n\n    # Validando e formatando range\n    if rng:\n        is_valid_range = validate_xrange(rng)\n        if not is_valid_range:\n            print(f'Invalid range: {rng}.')\n            return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n        if '!' in rng:\n            rng = rng.split('!')[-1]\n        request_range = f'{self.name}!{rng}'\n    else:\n        request_range = f'{self.name}'\n\n    # Criando requisi\u00e7\u00e3o\n    try:\n        request = self.service.values().get( \n            spreadsheetId = self.spreadsheet_id,\n            range = request_range\n        )\n    except Exception as e:\n        return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n    # Fazendo requisi\u00e7\u00e3o\n    response = self.client.execute(request)\n\n    # Resolvendo resposta da requisi\u00e7\u00e3o\n    if response.ok:\n        details['range'] = request_range\n        if response.data:\n            response.data = response.data.get('values')\n            if is_cell(rng) and isinstance(response.data, list) and len(response.data[0]) == 1:\n                response.data = response.data[0][0]\n\n        response.details = details\n\n    else:\n        if response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n\n    return response\n</code></pre>"},{"location":"references/sheet/#googleSheetsLib.core.Sheet.to_csv","title":"<code>to_csv(fp, rng='', sep=',')</code>","text":"<p>Fun\u00e7\u00e3o que pega os dados de uma planilha e salva em formato CSV.</p> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def to_csv(self, fp, rng = '', sep = ','):\n    \"Fun\u00e7\u00e3o que pega os dados de uma planilha e salva em formato CSV.\"\n    values = self.get_values(rng)\n    if values.data:\n        pd.DataFrame(values.data).to_csv(fp, index = False, sep = sep, header = False)\n</code></pre>"},{"location":"references/sheet/#googleSheetsLib.core.Sheet.update","title":"<code>update(values, rng='A1', value_input_option='USER_ENTERED', major_dimension='ROWS')</code>","text":"<p>Fun\u00e7\u00e3o que atualiza c\u00e9lulas da planilha.</p> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def update(self,\n           values:list[list],\n           rng:str = 'A1', \n           value_input_option:InputOption = 'USER_ENTERED',\n           major_dimension:MajorDimension = 'ROWS'):\n    \"Fun\u00e7\u00e3o que atualiza c\u00e9lulas da planilha.\"\n\n    details = self._get_dets(locals())\n    function_name = 'Sheet.update'\n\n    if rng:\n        is_valid_range = validate_xrange(rng)\n        if not is_valid_range:\n            print(f'Invalid range: {rng}.')\n            return Response.fail(f'Invalid x Range: {rng}.', function_name=function_name, details = details)\n        if '!' in rng:\n            rng = rng.split('!')[-1]\n        if ':' not in rng:\n            rng = get_values_delta(rng, values)\n        request_range = f'{self.name}!{rng}'\n    else:\n        return Response.fail(f'No range specified.', function_name=function_name, details = details)\n\n    # Validando par\u00e2metros adicionais:\n    if major_dimension not in get_args(MajorDimension):\n        error_msg = f'Args Error: Invalid major dimension {major_dimension}'\n        return Response.fail(error_msg, function_name = function_name, details = details)\n    if value_input_option not in get_args(InputOption):\n        error_msg = f'Args Error: Invalid input option {value_input_option}'\n        return Response.fail(error_msg, function_name = function_name, details = details)\n\n    body = {\n        'values' : values,\n        'majorDimension' : major_dimension\n    }\n\n    try:\n        request = self.service.values().update(\n            range = request_range,\n            spreadsheetId = self.spreadsheet_id,\n            body = body, \n            valueInputOption = value_input_option\n        )\n    except Exception as e:\n        return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n    response = self.client.execute(request)\n\n    if response.ok:\n        result = response.data\n        if result:\n            details['range'] = request_range\n            details['updated_range'] = result.get('updatedRange')\n            details['updated_cells'] = result.get('updatedCells')\n            details['updated_rows'] = result.get('updatedRows')\n            details['updated_columns'] = result.get('updatedColumns')\n        response.data = None\n        response.details = details\n        return response\n    else:\n        if response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n        return response\n</code></pre>"},{"location":"references/spreadsheet/","title":"Spreadsheet Handler","text":""},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet","title":"<code>googleSheetsLib.core.Spreadsheet</code>","text":"<p>Interface to handle Google Spreadsheets operations via API.</p> <p>This class serves as a wrapper to interface with Google Sheets. It can handle operations at the Spreadsheet level (metadata, batch updates) and acts as a  factory for Sheet objects.</p> <p>It handles authentication internally using the <code>ClientWrapper</code> class.</p> <p>For more information on the API, visit: https://developers.google.com/workspace/sheets/api/quickstart/python</p> <p>Attributes:</p> Name Type Description <code>spreadsheet_id</code> <code>str</code> <p>The unique ID of the Spreadsheet (found in the URL).</p> <code>name</code> <code>str</code> <p>The Spreadsheet's title.</p> <code>locale</code> <code>str</code> <p>The locale of the spreadsheet (e.g., 'en_US', 'pt_BR').</p> <code>timezone</code> <code>str</code> <p>The timezone of the spreadsheet.</p> <code>client</code> <code>ClientWrapper</code> <p>Handler for API requests, authentication, and retry logic.</p> <code>service</code> <code>SpreadsheetResource</code> <p>The authenticated Google Sheets API resource.</p> <code>batch_requests</code> <code>list[dict]</code> <p>Pending requests for the <code>batchUpdate</code> endpoint.</p> <code>batch_value_requests</code> <code>list[dict]</code> <p>Pending requests for the <code>values.batchUpdate</code> endpoint.</p> <code>last_refreshed</code> <code>datetime</code> <p>Timestamp of the last metadata update.</p> <code>metadata</code> <code>dict</code> <p>Raw dictionary containing the full Spreadsheet metadata.</p> <code>sheets_info</code> <code>dict</code> <p>Metadata for individual tabs (id, name, grid size), indexed by tab name.</p> <p>Parameters:</p> Name Type Description Default <code>spreadsheet_id</code> <code>str</code> <p>The ID found in the Google Sheets URL.</p> required <code>token_fp</code> <code>str</code> <p>File path to the auth token. Defaults to auth/token.json.</p> <code>TOKEN_PATH</code> <code>cred_fp</code> <code>str</code> <p>File path to the credentials JSON. Defaults to auth/cred.json.</p> <code>CRED_PATH</code> <code>scopes</code> <code>list[str]</code> <p>List of API scopes required. Defaults to SCOPES.</p> <code>SCOPES</code> Notes <p>You can setup the environment variables GOOGLE_SERVICE_CREDS and GOOGLE_SERVICE_TOKEN instead of directing to the credentials path. Just insert the JSON in plain text in them and the ClientWrapper will take care of the rest.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the Google Client cannot be created or authenticated.</p> Example <pre><code># Initialize the handler\nss = Spreadsheet(spreadsheet_id=\"1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms\")\n\n# Getting an individual tab:\ntab = ss['Tab Name']\ntab2 = ss.get_sheet_by_id(2084)\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>class Spreadsheet:\n    \"\"\"\n    Interface to handle Google Spreadsheets operations via API.\n\n    This class serves as a wrapper to interface with Google Sheets. It can handle\n    operations at the Spreadsheet level (metadata, batch updates) and acts as a \n    factory for Sheet objects.\n\n    It handles authentication internally using the `ClientWrapper` class.\n\n    For more information on the API, visit:\n    https://developers.google.com/workspace/sheets/api/quickstart/python\n\n\n    Attributes:\n        spreadsheet_id (str): The unique ID of the Spreadsheet (found in the URL).\n        name (str): The Spreadsheet's title.\n        locale (str): The locale of the spreadsheet (e.g., 'en_US', 'pt_BR').\n        timezone (str): The timezone of the spreadsheet.\n        client (ClientWrapper): Handler for API requests, authentication, and retry logic.\n        service (SpreadsheetResource): The authenticated Google Sheets API resource.\n        batch_requests (list[dict]): Pending requests for the `batchUpdate` endpoint.\n        batch_value_requests (list[dict]): Pending requests for the `values.batchUpdate` endpoint.\n        last_refreshed (dt.datetime): Timestamp of the last metadata update.\n        metadata (dict): Raw dictionary containing the full Spreadsheet metadata.\n        sheets_info (dict): Metadata for individual tabs (id, name, grid size), indexed by tab name.\n\n    Args:\n        spreadsheet_id (str): The ID found in the Google Sheets URL.\n        token_fp (str, optional): File path to the auth token. Defaults to auth/token.json.\n        cred_fp (str, optional): File path to the credentials JSON. Defaults to auth/cred.json.\n        scopes (list[str], optional): List of API scopes required. Defaults to SCOPES.\n\n    Notes:\n        You can setup the environment variables GOOGLE_SERVICE_CREDS and GOOGLE_SERVICE_TOKEN\n        instead of directing to the credentials path. Just insert the JSON in plain text\n        in them and the ClientWrapper will take care of the rest.\n\n    Raises:\n        ConnectionError: If the Google Client cannot be created or authenticated.\n\n    Example:\n        ```python\n        # Initialize the handler\n        ss = Spreadsheet(spreadsheet_id=\"1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms\")\n\n        # Getting an individual tab:\n        tab = ss['Tab Name']\n        tab2 = ss.get_sheet_by_id(2084)\n        ```\n    \"\"\"\n    def __init__(self, \n                 spreadsheet_id:str,\n                 token_fp:str = TOKEN_PATH,\n                 cred_fp:str = CRED_PATH,\n                 scopes:list[str] = SCOPES):\n\n        self.client = ClientWrapper(token_path=token_fp,\n                                    credentials_path=cred_fp,\n                                    scopes=scopes)\n        if not self.client.service:\n            print('Not possible to create Google Client.')\n            raise ConnectionError('Service not found. Check the credentials or the configs.')\n        self.spreadsheet_id = spreadsheet_id\n        self.service = self.client.service.spreadsheets() # type: ignore\n\n        self.name = ''\n        self.locale = ''\n        self.timezone = ''\n        self.sheets_info = dict()\n        self.batch_requests = []\n        self.batch_value_requests = []\n        self.last_refreshed = dt.datetime(1999,1,1,0,0,0)\n\n        # Construindo metadata:\n\n        metadata = self._get_metadata()\n        if metadata.data:\n            self.build_metadata(metadata.data)\n        else:\n            print('Not possible to build metadata. Error in the response.')\n\n    def _get_metadata(self) -&gt; Response:\n        \"\"\"\n        Internal method to help update metadata. It only makes the get request to the API\n        and returns an Response object containing the metadata for future parsing.\n\n        Returns:\n            Response: Response object containing either the metadata in the .data field,\n                or error information if the request failed.\n        \"\"\"\n        request = self.service.get(spreadsheetId = self.spreadsheet_id) \n        response = self.client.execute(request)\n        return response\n\n    def build_metadata(self, metadata) -&gt; bool:\n        \"\"\"\n        Method to parse metadata dict and update the object's metadata attributes.\n\n        It builds both the Spreadsheet's and the individual Tab's metadata.\n\n        Args:\n            metadata (dict): Dictionary containing the Spreadsheet's metadata, as structured\n                by the .get() request on the Spreadsheet resource.\n\n        Returns:\n            bool: If the build succeded or failed. False if the metadata is empty or\n                it generated a KeyError, True otherwise.\n\n        \"\"\"\n        if not metadata:\n            return False\n        try:\n            spreadsheet_metadata = metadata['properties']\n            sheets_metadata = metadata['sheets']\n\n            # Constru\u00edndo metadados da planilha como um todo:\n            self.name = spreadsheet_metadata['title']\n            self.locale = spreadsheet_metadata['locale']\n            self.timezone = spreadsheet_metadata['timeZone']\n            self.last_refreshed = dt.datetime.now()\n\n            # Construindo metadados das abas:\n            self.sheets_info.clear()\n\n            for sheet in sheets_metadata:\n                sheet = sheet['properties']\n                name = sheet['title']\n                sheet_id = sheet['sheetId']\n                row_count = sheet['gridProperties']['rowCount']\n                column_count = sheet['gridProperties']['columnCount']\n\n                self.sheets_info[name] = {\n                    'title': name,\n                    'sheet_id' : sheet_id,\n                    'row_count' : row_count,\n                    'column_count' : column_count\n                }\n\n            return True\n\n        except Exception as e:\n            print(f'Error while building metadata: {e}.')\n            return False\n\n    def refresh_metadata(self) -&gt; bool:\n        \"\"\"\n        Method to refresh metadata. It only requests the metadata to the API and \n        sends it to the build_metadata method.\n\n        Returns:\n            bool: if the refresh failed or succeded.\n        \"\"\"\n        logger.info('Refreshing metadata')\n        metadata = self._get_metadata()\n        if metadata.data:\n            return self.build_metadata(metadata.data)\n        else:\n            return False\n\n    def get_sheet(self, sheet_name:str) -&gt; Sheet | None:\n        \"\"\"\n        Retrieves a `Sheet` object by its name using cached metadata.\n\n        This method acts as a factory, returning a `Sheet` object initialized \n        with the data currently stored in `self.sheets_info`.\n\n        If the sheet exists in the Google Spreadsheet but not in the local metadata \n        (e.g., created recently), you must call `refresh_metadata()` first.\n\n        This method supports the subscript syntax (e.g., `spreadsheet['Tab Name']`).\n\n        Args:\n            sheet_name (str): The exact name of the tab as it appears in Google Sheets.\n\n        Returns:\n            Sheet: A Sheet object initialized with the tab's ID and dimensions.\n            None: If the sheet name is not found in the local metadata.\n\n        Example:\n            ```python\n            # Direct method call\n            inventory = ss.get_sheet('Inventory')\n\n            # Using subscript syntax (sugar)\n            sales = ss['Sales']\n\n            # Handling non-existent sheets\n            if not ss.get_sheet('Ghost Tab'):\n                print(\"Tab not found or metadata outdated.\")\n            ```\n        \"\"\"\n        logger.info(f'Building Sheet object. Searching for sheet {sheet_name} in local metadata...')\n        if sheet_name in self.sheets_info:\n            sheet_info = self.sheets_info[sheet_name]\n            return Sheet(\n                name = sheet_name,\n                id = sheet_info['sheet_id'],\n                service = self.service,\n                client = self.client,\n                row_count = sheet_info['row_count'],\n                column_count = sheet_info['column_count'],\n                parent_spreadsheet = self\n            )\n        else:\n            logger.warning(f'Sheet {sheet_name} not found. Try refreshing the metadata or check your spelling.')\n            return None\n\n    def get_sheet_by_id(self, id:int) -&gt; Sheet | None:\n        \"\"\"\n        Retrieves a `Sheet` object by its id using cached metadata.\n\n        It's useful if you rename a tab, but maintain the id in a varibable.\n\n        To access a tab's id, get the Sheet's metadata in self.sheets_info and\n        check the sheet_id value.\n\n        This method acts as a factory, returning a `Sheet` object initialized \n        with the data currently stored in `self.sheets_info`.\n\n        If the sheet exists in the Google Spreadsheet but not in the local metadata \n        (e.g., created recently), you must call `refresh_metadata()` first.\n\n        This method supports the subscript syntax (e.g., `spreadsheet[id]`).\n\n        Args:\n            id (int): The tab's id. This is an internal id that has to be accessed\n                by the Spreadsheet's metadata.\n\n        Returns:\n            Sheet: A Sheet object initialized with the tab's ID and dimensions.\n            None: If the sheet name is not found in the local metadata.\n\n        Example:\n            ```python\n            # Direct method call\n            inventory = ss.get_sheet_by_id(49203)\n\n            # Using subscript syntax (sugar)\n            sales = ss[2384]\n\n            # Using the sheets_info metadata:\n            sheet_metadata = ss.sheets_info['Sales']\n            sheet_id = sheet_metadata['sheet_id']\n            sales = ss.get_sheet_by_id(sheet_id)\n\n            # Handling non-existent sheets\n            if not ss.get_sheet_by_id(3232):\n                print(\"Tab not found or metadata outdated.\")\n            ```\n        \"\"\"\n        name = ''\n        for sheet_info in self.sheets_info.values():\n            if sheet_info['sheet_id'] == id:\n                name = sheet_info['title']\n                break\n        if name:\n            return self.get_sheet(name)\n        else:\n            logger.warning(f'Sheet ID {id} not found.')\n            return None\n\n    def execute_batch(self) -&gt; Response:\n        \"\"\"\n        Executes all pending requests in the batch queue via the `batchUpdate` endpoint.\n\n        This method compiles all operations stored in `self.batch_requests`, wraps them \n        into a single API call, and passes it to the client handler.\n\n        If the execution is successful, the method should ideally clear the pending \n        requests queue.\n\n        Returns:\n            Response: A custom response object. \n                - If successful (`response.ok` is True), contains the API reply.\n                - If failed, contains error details and the function name context.\n\n        Example:\n            ```python\n            # Add some operations (e.g., delete rows, format cells)\n            ss.batch_requests.append(delete_rows_request)\n            ss.batch_requests.append(format_header_request)\n\n            # Send everything in one go\n            resp = ss.execute_batch()\n\n            if resp.ok:\n                print(\"Batch update successful!\")\n            else:\n                print(f\"Error: {resp.error}\")\n            ```\n        \"\"\"\n        requests = self.batch_requests\n        details = self._get_dets(locals())\n        function_name = 'Spreadsheet.execute_batch'\n        if not requests:\n            return Response.fail('No request to execute.', function_name=function_name, details = details)\n        try:\n            body: BatchUpdateSpreadsheetRequest = {'requests' : requests} # type: ignore\n            request = self.service.batchUpdate(\n                spreadsheetId=self.spreadsheet_id,\n                body = body\n            )\n        except Exception as e:\n            return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n        response = self.client.execute(request)\n\n        if response.ok:\n            response.details = details\n            self.batch_requests = []\n\n        elif response.error:\n            response.error.details = details\n            response.error.function_name = function_name\n\n        return response\n\n\n    def get_info(self) -&gt; dict:\n        \"\"\"\n        Returns a simple dictionary containing the Spreadsheet's info. \n\n        Useful for serialization.\n\n        Returns:\n            dict: Dictionary with spreadsheet_id, name, last refreshed and tabs info.\n        \"\"\"\n        return {\n            'spreadsheet_id' : self.spreadsheet_id,\n            'name' : self.name,\n            'timezone' : self.timezone,\n            'locale' : self.locale,\n            'last_refreshed' : str(self.last_refreshed),\n            'sheets' : self.sheets_info\n        }\n\n    def _get_dets(self, locals:dict):\n        \"\"\"\n        Internal method to create details about a method execution, mostly\n        to attach to Response type objects.\n\n        Receives a dictionary of parameters, generally representing the local namespace,\n        and returns an enriched and cleaned dictionary with the Spreadsheet's info.\n\n        Args:\n            locals (dict): dict with runtime parameters used to build the details dictionary.\n\n        Returns:\n            deets (dict): data received enriched with aditional Spreadsheet information. \n        \"\"\"\n        deets = locals.copy()\n        if 'self' in deets:\n            del deets['self']\n        deets['spreadsheet_info'] = self.get_info()\n        return deets\n\n    def __getitem__(self, sheet: int | str):\n        \"\"\"\n        Dunder method to implement subscript syntax for both get_sheet and get_sheet_by_id.\n\n        If it receives a string, calls get_sheet.\n        If it receives an integer, calls get_sheet_by_id.\n\n        Args:\n            sheet (str | int): The sheet's name or id to be created.\n        Returns:\n            Sheet: Sheet type object if the Sheet object creation was succesfull.\n            None: If it couldn't find the id or name in the metadata.\n        Raises:\n            ValueError: if the received parameter is neither str or int.\n        \"\"\"\n        if isinstance(sheet, int):\n            return self.get_sheet_by_id(sheet)\n        elif isinstance(sheet, str):\n            return self.get_sheet(sheet)\n        else:\n            raise ValueError(f'Unexpected parameter type: {type(sheet)}.')\n</code></pre>"},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet.build_metadata","title":"<code>build_metadata(metadata)</code>","text":"<p>Method to parse metadata dict and update the object's metadata attributes.</p> <p>It builds both the Spreadsheet's and the individual Tab's metadata.</p> <p>Parameters:</p> Name Type Description Default <code>metadata</code> <code>dict</code> <p>Dictionary containing the Spreadsheet's metadata, as structured by the .get() request on the Spreadsheet resource.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the build succeded or failed. False if the metadata is empty or it generated a KeyError, True otherwise.</p> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def build_metadata(self, metadata) -&gt; bool:\n    \"\"\"\n    Method to parse metadata dict and update the object's metadata attributes.\n\n    It builds both the Spreadsheet's and the individual Tab's metadata.\n\n    Args:\n        metadata (dict): Dictionary containing the Spreadsheet's metadata, as structured\n            by the .get() request on the Spreadsheet resource.\n\n    Returns:\n        bool: If the build succeded or failed. False if the metadata is empty or\n            it generated a KeyError, True otherwise.\n\n    \"\"\"\n    if not metadata:\n        return False\n    try:\n        spreadsheet_metadata = metadata['properties']\n        sheets_metadata = metadata['sheets']\n\n        # Constru\u00edndo metadados da planilha como um todo:\n        self.name = spreadsheet_metadata['title']\n        self.locale = spreadsheet_metadata['locale']\n        self.timezone = spreadsheet_metadata['timeZone']\n        self.last_refreshed = dt.datetime.now()\n\n        # Construindo metadados das abas:\n        self.sheets_info.clear()\n\n        for sheet in sheets_metadata:\n            sheet = sheet['properties']\n            name = sheet['title']\n            sheet_id = sheet['sheetId']\n            row_count = sheet['gridProperties']['rowCount']\n            column_count = sheet['gridProperties']['columnCount']\n\n            self.sheets_info[name] = {\n                'title': name,\n                'sheet_id' : sheet_id,\n                'row_count' : row_count,\n                'column_count' : column_count\n            }\n\n        return True\n\n    except Exception as e:\n        print(f'Error while building metadata: {e}.')\n        return False\n</code></pre>"},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet.refresh_metadata","title":"<code>refresh_metadata()</code>","text":"<p>Method to refresh metadata. It only requests the metadata to the API and  sends it to the build_metadata method.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if the refresh failed or succeded.</p> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def refresh_metadata(self) -&gt; bool:\n    \"\"\"\n    Method to refresh metadata. It only requests the metadata to the API and \n    sends it to the build_metadata method.\n\n    Returns:\n        bool: if the refresh failed or succeded.\n    \"\"\"\n    logger.info('Refreshing metadata')\n    metadata = self._get_metadata()\n    if metadata.data:\n        return self.build_metadata(metadata.data)\n    else:\n        return False\n</code></pre>"},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet.get_sheet","title":"<code>get_sheet(sheet_name)</code>","text":"<p>Retrieves a <code>Sheet</code> object by its name using cached metadata.</p> <p>This method acts as a factory, returning a <code>Sheet</code> object initialized  with the data currently stored in <code>self.sheets_info</code>.</p> <p>If the sheet exists in the Google Spreadsheet but not in the local metadata  (e.g., created recently), you must call <code>refresh_metadata()</code> first.</p> <p>This method supports the subscript syntax (e.g., <code>spreadsheet['Tab Name']</code>).</p> <p>Parameters:</p> Name Type Description Default <code>sheet_name</code> <code>str</code> <p>The exact name of the tab as it appears in Google Sheets.</p> required <p>Returns:</p> Name Type Description <code>Sheet</code> <code>Sheet | None</code> <p>A Sheet object initialized with the tab's ID and dimensions.</p> <code>None</code> <code>Sheet | None</code> <p>If the sheet name is not found in the local metadata.</p> Example <pre><code># Direct method call\ninventory = ss.get_sheet('Inventory')\n\n# Using subscript syntax (sugar)\nsales = ss['Sales']\n\n# Handling non-existent sheets\nif not ss.get_sheet('Ghost Tab'):\n    print(\"Tab not found or metadata outdated.\")\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def get_sheet(self, sheet_name:str) -&gt; Sheet | None:\n    \"\"\"\n    Retrieves a `Sheet` object by its name using cached metadata.\n\n    This method acts as a factory, returning a `Sheet` object initialized \n    with the data currently stored in `self.sheets_info`.\n\n    If the sheet exists in the Google Spreadsheet but not in the local metadata \n    (e.g., created recently), you must call `refresh_metadata()` first.\n\n    This method supports the subscript syntax (e.g., `spreadsheet['Tab Name']`).\n\n    Args:\n        sheet_name (str): The exact name of the tab as it appears in Google Sheets.\n\n    Returns:\n        Sheet: A Sheet object initialized with the tab's ID and dimensions.\n        None: If the sheet name is not found in the local metadata.\n\n    Example:\n        ```python\n        # Direct method call\n        inventory = ss.get_sheet('Inventory')\n\n        # Using subscript syntax (sugar)\n        sales = ss['Sales']\n\n        # Handling non-existent sheets\n        if not ss.get_sheet('Ghost Tab'):\n            print(\"Tab not found or metadata outdated.\")\n        ```\n    \"\"\"\n    logger.info(f'Building Sheet object. Searching for sheet {sheet_name} in local metadata...')\n    if sheet_name in self.sheets_info:\n        sheet_info = self.sheets_info[sheet_name]\n        return Sheet(\n            name = sheet_name,\n            id = sheet_info['sheet_id'],\n            service = self.service,\n            client = self.client,\n            row_count = sheet_info['row_count'],\n            column_count = sheet_info['column_count'],\n            parent_spreadsheet = self\n        )\n    else:\n        logger.warning(f'Sheet {sheet_name} not found. Try refreshing the metadata or check your spelling.')\n        return None\n</code></pre>"},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet.get_sheet_by_id","title":"<code>get_sheet_by_id(id)</code>","text":"<p>Retrieves a <code>Sheet</code> object by its id using cached metadata.</p> <p>It's useful if you rename a tab, but maintain the id in a varibable.</p> <p>To access a tab's id, get the Sheet's metadata in self.sheets_info and check the sheet_id value.</p> <p>This method acts as a factory, returning a <code>Sheet</code> object initialized  with the data currently stored in <code>self.sheets_info</code>.</p> <p>If the sheet exists in the Google Spreadsheet but not in the local metadata  (e.g., created recently), you must call <code>refresh_metadata()</code> first.</p> <p>This method supports the subscript syntax (e.g., <code>spreadsheet[id]</code>).</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>The tab's id. This is an internal id that has to be accessed by the Spreadsheet's metadata.</p> required <p>Returns:</p> Name Type Description <code>Sheet</code> <code>Sheet | None</code> <p>A Sheet object initialized with the tab's ID and dimensions.</p> <code>None</code> <code>Sheet | None</code> <p>If the sheet name is not found in the local metadata.</p> Example <pre><code># Direct method call\ninventory = ss.get_sheet_by_id(49203)\n\n# Using subscript syntax (sugar)\nsales = ss[2384]\n\n# Using the sheets_info metadata:\nsheet_metadata = ss.sheets_info['Sales']\nsheet_id = sheet_metadata['sheet_id']\nsales = ss.get_sheet_by_id(sheet_id)\n\n# Handling non-existent sheets\nif not ss.get_sheet_by_id(3232):\n    print(\"Tab not found or metadata outdated.\")\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def get_sheet_by_id(self, id:int) -&gt; Sheet | None:\n    \"\"\"\n    Retrieves a `Sheet` object by its id using cached metadata.\n\n    It's useful if you rename a tab, but maintain the id in a varibable.\n\n    To access a tab's id, get the Sheet's metadata in self.sheets_info and\n    check the sheet_id value.\n\n    This method acts as a factory, returning a `Sheet` object initialized \n    with the data currently stored in `self.sheets_info`.\n\n    If the sheet exists in the Google Spreadsheet but not in the local metadata \n    (e.g., created recently), you must call `refresh_metadata()` first.\n\n    This method supports the subscript syntax (e.g., `spreadsheet[id]`).\n\n    Args:\n        id (int): The tab's id. This is an internal id that has to be accessed\n            by the Spreadsheet's metadata.\n\n    Returns:\n        Sheet: A Sheet object initialized with the tab's ID and dimensions.\n        None: If the sheet name is not found in the local metadata.\n\n    Example:\n        ```python\n        # Direct method call\n        inventory = ss.get_sheet_by_id(49203)\n\n        # Using subscript syntax (sugar)\n        sales = ss[2384]\n\n        # Using the sheets_info metadata:\n        sheet_metadata = ss.sheets_info['Sales']\n        sheet_id = sheet_metadata['sheet_id']\n        sales = ss.get_sheet_by_id(sheet_id)\n\n        # Handling non-existent sheets\n        if not ss.get_sheet_by_id(3232):\n            print(\"Tab not found or metadata outdated.\")\n        ```\n    \"\"\"\n    name = ''\n    for sheet_info in self.sheets_info.values():\n        if sheet_info['sheet_id'] == id:\n            name = sheet_info['title']\n            break\n    if name:\n        return self.get_sheet(name)\n    else:\n        logger.warning(f'Sheet ID {id} not found.')\n        return None\n</code></pre>"},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet.execute_batch","title":"<code>execute_batch()</code>","text":"<p>Executes all pending requests in the batch queue via the <code>batchUpdate</code> endpoint.</p> <p>This method compiles all operations stored in <code>self.batch_requests</code>, wraps them  into a single API call, and passes it to the client handler.</p> <p>If the execution is successful, the method should ideally clear the pending  requests queue.</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>A custom response object.  - If successful (<code>response.ok</code> is True), contains the API reply. - If failed, contains error details and the function name context.</p> Example <pre><code># Add some operations (e.g., delete rows, format cells)\nss.batch_requests.append(delete_rows_request)\nss.batch_requests.append(format_header_request)\n\n# Send everything in one go\nresp = ss.execute_batch()\n\nif resp.ok:\n    print(\"Batch update successful!\")\nelse:\n    print(f\"Error: {resp.error}\")\n</code></pre> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def execute_batch(self) -&gt; Response:\n    \"\"\"\n    Executes all pending requests in the batch queue via the `batchUpdate` endpoint.\n\n    This method compiles all operations stored in `self.batch_requests`, wraps them \n    into a single API call, and passes it to the client handler.\n\n    If the execution is successful, the method should ideally clear the pending \n    requests queue.\n\n    Returns:\n        Response: A custom response object. \n            - If successful (`response.ok` is True), contains the API reply.\n            - If failed, contains error details and the function name context.\n\n    Example:\n        ```python\n        # Add some operations (e.g., delete rows, format cells)\n        ss.batch_requests.append(delete_rows_request)\n        ss.batch_requests.append(format_header_request)\n\n        # Send everything in one go\n        resp = ss.execute_batch()\n\n        if resp.ok:\n            print(\"Batch update successful!\")\n        else:\n            print(f\"Error: {resp.error}\")\n        ```\n    \"\"\"\n    requests = self.batch_requests\n    details = self._get_dets(locals())\n    function_name = 'Spreadsheet.execute_batch'\n    if not requests:\n        return Response.fail('No request to execute.', function_name=function_name, details = details)\n    try:\n        body: BatchUpdateSpreadsheetRequest = {'requests' : requests} # type: ignore\n        request = self.service.batchUpdate(\n            spreadsheetId=self.spreadsheet_id,\n            body = body\n        )\n    except Exception as e:\n        return Response.fail(f'Error while building request: {e}', function_name=function_name, details=details)\n\n    response = self.client.execute(request)\n\n    if response.ok:\n        response.details = details\n        self.batch_requests = []\n\n    elif response.error:\n        response.error.details = details\n        response.error.function_name = function_name\n\n    return response\n</code></pre>"},{"location":"references/spreadsheet/#googleSheetsLib.core.Spreadsheet.get_info","title":"<code>get_info()</code>","text":"<p>Returns a simple dictionary containing the Spreadsheet's info. </p> <p>Useful for serialization.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Dictionary with spreadsheet_id, name, last refreshed and tabs info.</p> Source code in <code>src/googleSheetsLib/core.py</code> <pre><code>def get_info(self) -&gt; dict:\n    \"\"\"\n    Returns a simple dictionary containing the Spreadsheet's info. \n\n    Useful for serialization.\n\n    Returns:\n        dict: Dictionary with spreadsheet_id, name, last refreshed and tabs info.\n    \"\"\"\n    return {\n        'spreadsheet_id' : self.spreadsheet_id,\n        'name' : self.name,\n        'timezone' : self.timezone,\n        'locale' : self.locale,\n        'last_refreshed' : str(self.last_refreshed),\n        'sheets' : self.sheets_info\n    }\n</code></pre>"}]}